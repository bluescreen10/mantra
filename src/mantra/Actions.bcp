class mantra::Actions is HLL::Actions;

our @?BLOCK;
our $?BLOCK;

INIT {
    our @?BLOCK := Q:PIR { %r = root_new ['parrot';'ResizablePMCArray'] };
    our $?BLOCK := PAST::Block.new( :hll<mantra>, :blocktype<declaration> );

    @?BLOCK.push($?BLOCK);
}

# Called at the beginning of the parsing usefull to wrap up everything
method begin($/) {
    our $?BLOCK;
    our @?BLOCK;

    $?BLOCK := PAST::Block.new(:hll<mantra>, :blocktype<declaration>);


    Q:PIR {   $P0 = get_hll_global 'Object'
              unless null $P0 goto already_loaded
              setup_protoobject()
#              load('Object')
              load('System')
            already_loaded:
          };

    # $?BLOCK.loadinit.unshift(
    #     PAST::Op.new(
    #         :pasttype<inline>,
    #         :inline('   $P0 = get_hll_global "Object" ',
    #                 '   unless null $P0 goto finish_setup',
    #                 ' finish_setup:')
    #     )
    # );

    # Built-in Globals
    $?BLOCK.symbol( 'Object', :scope<package>);
    $?BLOCK.symbol( 'String', :scope<package>);
    $?BLOCK.symbol( 'true',   :scope<package>);
    $?BLOCK.symbol( 'false',  :scope<package>);

    # Register TOP level block
    @?BLOCK.push($?BLOCK);

}

method TOP($/) {
    our $?BLOCK;
    our @?BLOCK;

    # Get the parent block
    my $past := @?BLOCK.pop();
    $past.push($<statement_list>.ast);
    make $past;
}

# Statements
method statement_list($/) {
    my $past := PAST::Stmts.new();

    for $<statement> {
        $past.push($_.ast);
    }

    make $past;
}

method statement($/) {
    if $<expression> {
        make $<expression>.ast;
    }
}

method return_statement($/) {
    make PAST::Op.new( :inline(
            '   store_lex ":return_value", %0',
            '   $P0 = find_lex ":return_address"',
            '.tailcall $P0()'
        ),
        $<basic_expression>.ast
    );
}

method basic_expression($/) {
    if $<primitive> {
        make $<primitive>.ast;
    } elsif $<primary> {
        if $<message> {
            my $past := PAST::Stmts.new();
#            my $primary := PAST::Op.new( :pasttype<inline>, :inline( ' .lex ":primary", %0'));
#            $primary.push($<primary>.ast);
#            $past.push($primary);
            for $<message> {
                $past.push($_.ast);
                #Last in the chain
                for $_.ast.iterator() {
                }
                $_.ast.unshift($<primary>.ast);
            }
            make $past;
        } else {
            make $<primary>.ast;
        }
    }
}

method expression($/) {
    if $<basic_expression> {
        make $<basic_expression>.ast;
    } elsif $<assignment> {
        make $<assignment>.ast;
    } elsif $<return_statement> {
        make $<return_statement>.ast;
    }
}

method message($/) {
    # Unary message chain
    if $<unary_chain> {
        make $<unary_chain>.ast
    }

    # Binary message chain
    elsif $<binary_first> {
        make $<binary_first>.ast;
    }

    # Keyword message
    elsif $<keyword_first> {
        make $<keyword_first>.ast;
    }
}

method unary_chain($/) {

    my $msg := PAST::Op.new(
        :name('call_method'),
        :pasttype('callmethod'),
        :node($/)
    );

    $msg.push(
        PAST::Val.new(
            :returns<String>,
            :value( $<unary_method>.shift )
        )
    );

    for $<unary_method> {
        my $next := PAST::Op.new( :pasttype<callmethod>, :name<call_method> );
#        $msg.unshift($next);
        $next.push( PAST::Val.new( :returns<String>, :value($_) ) );
        $next.unshift( $msg );
        $msg := $next;
    }

        # for $<binary_second> {
        #     my $message := PAST::Val.new(
        #         :returns<String>,
        #         :value($_<method_name>)
        #     );

        #     my $next := PAST::Op.new(
        #         :name('call_method'),
        #         :pasttype('callmethod'),
        #     );

        #     $next.push($past);
        #     $next.push($message);
        #     $next.push($_<primary>.ast);
        #     $past := $next;
        # }

        # if $<keyword_third> {
        #     say("Keyworkd third:"~$<keyword_third>[0]);
        #     my $next := $<keyword_third>[0].ast;
        #     $next.unshift($past);
        #     $past := $next;
        # }
     make $msg;
}

method binary_message($/) {
    my $argument;

    for $<unary_method> {
        my $message := PAST::Val.new( :returns<String>,
                                      :value($_) );
        if $argument {
            my $next := PAST::Op.new(
                :name('call_method'),
                :pasttype('callmethod'),
                :node($/)
            );

            $next.push($argument);
            $next.push($message);
            $argument := $next;
        } else {

            $argument := PAST::Op.new(
                :name('call_method'),
                :pasttype('callmethod'),
                :node($/)
            );
            $argument.push($<primary>.ast);
            $argument.push($message);
        }
    }

    unless $argument {
        $argument := $<primary>.ast;
    }

    my $past := PAST::Op.new(
        :name('call_method'),
        :pasttype('callmethod'),
        :node($/)
    );

    $past.push(
        PAST::Val.new(
            :returns<String>,
            :value($<method_name>)
        )
    );

    $past.push($argument);
    make $past;

}

method keyword_message($/) {
    my $past := PAST::Op.new(
        :name('call_method'),
        :pasttype('callmethod'),
        :node($/)
    );
    $past.push(PAST::Val.new( :returns<String>,
                              :value(pir::join(':',$<method_name>)~':') ) );
    for $<keyword_argument> {
        $past.push( $_.ast );
    }
    make $past;
}

method keyword_argument($/) {
    my $primary;
    for $<unary_method> {
        my $message := PAST::Val.new( :returns<String>,
                                      :value($_) );
        if $primary {
#            my $next := PAST::Op.new( :name('!call_method'),
            my $next := PAST::Op.new( :name('call_method'),
                                      :pasttype('callmethod'),
                                      :node($/) );
            $next.push($primary);
            $next.push($message);
            $primary := $next;
        } else {
#            $primary := PAST::Op.new( :name('!call_method'),
            $primary := PAST::Op.new( :name('call_method'),
                                      :pasttype('callmethod'),
                                      :node($/) );
            $primary.push($<primary>.ast);
            $primary.push($message);
        }
    }

    unless $primary {
        $primary := $<primary>.ast;
    }

    my $past;

    for $<binary_message> {
        $past := $_.ast;
        $past.unshift($primary);
        $primary := $past;
    }

        if $past {
            make $past;
        } else {
            make $primary
        }
}

method primary($/) {
    our @?BLOCK;
    our $?BLOCK;

    if $<variable> {
        my $past := $<variable>.ast;

        unless $past.scope() {
            for @?BLOCK {
                my $variable := $_.symbol( $<variable> );
                if $variable {
                    $past.scope($variable<scope>);
                }
            }
        }
        make $past;
    }
    elsif $<literal> {
        make $<literal>.ast;
    }
    elsif $<basic_expression> {
        make $<basic_expression>.ast
    }
    elsif $<block> {
        make $<block>.ast;
    }
}

method variable($/) {
    if $<pseudo_variable_self> {
        make $<pseudo_variable_self>.ast;
    }
    elsif $<instance_variable> {
        make $<instance_variable>.ast;
    }
    elsif $<lexical_variable> {
        make $<lexical_variable>.ast;
    }
}

method instance_variable ($/) {
    make PAST::Var.new( :name(~$<ident>), :scope<attribute>, :node($/) );
}

method pseudo_variable_self($/) {
    make PAST::Var.new( :name<self>, :scope<lexical> );
}


method literal($/) {
    my $past;

    if $<string_constant> {
        $past := PAST::Op.new(
            :name('copy_set_value'),
            :pasttype('callmethod'),
            :node($/)
        );

        $past.push(PAST::Var.new( :name<String>, :scope<package> ));
        $past.push($<string_constant>.ast);
    }
    elsif $<literal_number> {
        $past := $<literal_number>.ast;
    }

    make $past;
}

method primitive($/) {
    make $<primitive_contents>.ast;
}

method primitive_contents($/) {
    my $past := PAST::Op.new(
        :name( $<primitive_name> )
    );

    for $<primary> {
        $past.push( $_.ast );
    }

    make $past;
}

method is_global($variable) {
    our @?BLOCK;
    our $?BLOCK;

    # Currently at global scope
    if @?BLOCK[1] eq $?BLOCK {
        return 1;
    }

    for @?BLOCK {
        my $hash := $_.symbol( $variable.name() );
        # say("name:"~$variable.name());
        # say("scope:"~$hash<scope>);
        if $_.symbol( $variable.name() &&
           $_.symbol( $variable.name() ) eq "package" ) {
            return 1;
        }
    }

    return 0;
}

method is_registered($variable) {
    our @?BLOCK;

    # Search through lexical vars
    for @?BLOCK {
        if $_.symbol($variable.name()) {
            return 1;
        }
    }

    return 0;
}

method assignment($/) {
    our @?BLOCK;
    our $?BLOCK;

    my $variable := $<assignment_target>.ast;

    # Dynamic Scope
    unless $variable.scope() {
        # Global or lexicals
        if self.is_global($variable) {
            $variable.scope('package');

            # Register Global Variable
            unless self.is_registered( $variable ) {
                $variable.isdecl(1);
                @?BLOCK[0].symbol( $variable.name, :scope<package> );
            }
        }
        else {
            $variable.scope('lexical');
            unless self.is_registered( $variable ) {
                $variable.isdecl(1);
                $?BLOCK.symbol( $variable.name(), :scope<lexical>);
            }
        }
    }

    $variable.lvalue(1);
    my $value := $<basic_expression>.ast;

    make PAST::Op.new( $variable,
                       $value,
                       :pasttype<bind>,
                       :node($/) );
}

method assignment_target($/) {
    make $<variable>.ast;
}

method lexical_variable($/) {
    make PAST::Var.new( :name($<name>), :node($/) );
}


# BLOCK
method begin_block($/) {
    our $?BLOCK;
    our @?BLOCK;

    $?BLOCK := PAST::Block.new(:blocktype<declaration>);
#    $?BLOCK.closure(1);
    @?BLOCK.push($?BLOCK);

}

method block($/) {
    our $?BLOCK;
    our @?BLOCK;

    @?BLOCK.pop();

    $?BLOCK := @?BLOCK[-1];

    my $past := PAST::Op.new(
        :name('copy_set_value'),
        :pasttype('callmethod'),
        :node($/)
    );

    $past.push(PAST::Var.new( :name<Block>, :scope<package> ));
    $past.push($<block_contents>.ast);
    make $past;
}

method block_contents($/) {
    our $?BLOCK;
    our @?BLOCK;

    for $<ident> {
        $?BLOCK.push( PAST::Var.new( :name($_), :scope<parameter> ) );
        $?BLOCK.symbol($_, :scope('lexical'));
    }

    $?BLOCK.push($<statement_list>.ast);
    make $?BLOCK;
}

method string_constant($/) {
    my $past := $<quote>.ast;
    $past.returns('String');
    make $past;
}

method quote:sym<'>($/) { make $<quote_EXPR>.ast; }
method quote:sym<">($/) { make $<quote_EXPR>.ast; }


# Literal Number
method literal_number($/) {
    if $<integer> {
        make $<integer>.ast;
    }
}

# Integer
method integer($/) {
    my $past := PAST::Op.new(
         :name('copy_set_value'),
         :pasttype('callmethod'),
         :node($/)
    );

    # Internal Integer type
    $past.push(
        PAST::Var.new( :name<Integer>, :scope<package> )
    );

    # Parrot's built-in integer
    $past.push(
        PAST::Val.new( :returns<Integer>, :value($/) )
    );

    make $past;
}
