=begin overview

This is the grammar for mantra in Perl 6 rules.

=end overview

grammar mantra::Grammar is HLL::Grammar;

token TOP {
    <.begin>
    <statement_list>
    [ $ || <.panic: 'Syntax error'> ]
}

token begin {
    <?>
}

# Statement list
rule statement_list {
    [ <statement> ** <dot> ]*
}

## General grammars

## Method defintion

token unary_method {
    <method_name=ident>
}


# Statement
rule statement {
    <dot>*
    <expression>
    <dot>*
}

token dot {
    '.'
}

rule expression {
    | <assignment>
    | <return_statement>
    | <basic_expression>
}

rule return_statement { '^' <basic_expression> }

rule basic_expression {
    | <primitive>
    | <primary> [ <message> ** ';' ]?
}


# Block
rule block { '{' ~ '}' <block_contents> }

rule block_contents {
    <.begin_block>
    [ <ident> <ident>* '|' ]? <statement_list>
}

token begin_block {
    <?>
}

# /Block

rule message {
   | <keyword_first=keyword_message>
   | <binary_first=binary_message>
   | <unary_chain>
}

rule unary_chain {
   [ <unary_method> ]+
   <binary_message>*
   <keyword_message>?
}

token binary_message {
    <method_name=binary_method_name> <ws>
    <primary>
        [ \h* <unary_method>
             [
             | <?before <.ws> \w+ ':'>
             | <?before '.'>
             | <?before \s+>
             ]
        ]*
}

token keyword_message {
    <method_name=ident> ':' <ws> <keyword_argument>
    [ <ws> <method_name=ident> ':' <ws> <keyword_argument> ]*
}

token keyword_argument {
    <primary>
        [ \h* <unary_method>
              [
              | <?before \w+ ':' >
              | <?before \s+>
              | <?before '.'>
              ]
        ]*
        [ \h* <binary_message>
              [
              | <?before \w+ ':'>
              | <?before \h*>
              | <?before '.'>
              ]
        ]*
}

rule primary {
     | <variable>
     | <literal>
     | '(' ~ ')' <basic_expression>
     | <block>
}

token variable {
    | <pseudo_variable_self>
    | <instance_variable>
    | <lexical_variable>
}

token assignment {
     <assignment_target> ':' \h* <basic_expression>
}

rule assignment_target {
     <!reserved_words><variable>
}

token pseudo_variable_self {
    'self'
}

token instance_variable {
     '@' <ident>
}

token lexical_variable {
     <name=ident>
}


# # Tokens

token reserved_words {
#     | 'Object'  #Do we really want object here?
     | 'null'
     | 'self'
}

token binary_method_name {
     [ '!' | '%' | '+' | '-' | '/' | '<' | '=' | '>'
     | '?' | '$' | '\\' | '~' | '|' | '*' | ',' ]+
}

token literal {
    | <string_constant>
    | <literal_number>
}

token string_constant { <quote> }

proto token quote { <...> }
token quote:sym<'> { <?[']> <quote_EXPR: ':q'> }

token literal_number {
    <integer>
}

token integer {
    ['-']? \s* \d+
}

# token absolute_number {
#    | <absolute_float>   {*} #= absolute_float
#    | <absolute_integer> {*} #= absolute_integer
# }

# token absolute_integer {
#    \d+
#    {*}
# }

# token absolute_float {
#    \d+ '.' \d+
#    {*}
# }

token primitive {
    '<' ~ '>'  <primitive_contents>
}

token primitive_contents {
     <primitive_name> '(' [ <primary> ** ',' ]? ')'
}

token primitive_name {
     <ident>
}

##  this <ws> rule treats # as "comment to eol"
##  you may want to replace it with something appropriate
token ws {
    <!ww>
    [ '#' \N* \n? | \s+ | \n+ ]*
}
